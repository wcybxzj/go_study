==============================================================================
================================1.单机版外部归并排序==============================
==============================================================================
使用方式:
1.cmd/pipelinedemo/main.go, 生成需要排序的乱序文件  /tmp/large.in  或者 /tmp/small.in
2.cmd/externalsort/sort.go, 对未排序的文件进行排序  /tmp/large.out  或者 /tmp/small.out
==============================================================================
优化1:系统调用效率太低:
cmd/pipelinedemon/main.go:
尽量不要直接使用系统调用来进行IO,尽量使用bufio但是write时候要Flush,
==============================================================================
优化2:channel尽量加缓存:
pipeline/nodes.go/ReaderSource节点:
channel如果不加缓存,即使从文件读取是bufio的,因为受制于channel实际还是要等有人从channel读取才能进行下一次的读文件

pipeline/nodes.go/Merge节点:
channel如果不加缓存,就是每次合并后都要等有人来从channel读取,才能进行下一次的merge工作

pipeline/nodes.go/InMemorySort节点:
同上

对比测试:执行cmd/externalsort/sort.go
3个节点使用缓存前:
Read done: 6.859280923s
Read done: 8.770342336s
Read done: 13.624619613s
InMemorySort done: 15.654856005s
Read done: 15.839768725s
InMemorySort done: 17.530371715s
InMemorySort done: 22.194624759s
InMemorySort done: 24.157531593s
Merge done: 1m29.860976227s//<--------------------
Merge done: 1m29.861001856s//<--------------------
Merge done: 1m29.861003569s//<--------------------

3个节点使用缓存后:
Read done: 8.768863441s
Read done: 12.728636847s
Read done: 13.398045745s
Read done: 15.659087367s
InMemorySort done: 18.058755551s
InMemorySort done: 21.66573442s
InMemorySort done: 22.255190097s
InMemorySort done: 23.785650549s
Merge done: 45.192243125s//<--------------------
Merge done: 45.192332336s//<--------------------
Merge done: 45.192514886s//<--------------------

结论:可以看到channel加上只有merge速度有提升

==============================================================================
================================2.网络版外部归并排序=============================
==============================================================================
使用方式:同1.单机版外部归并排序
