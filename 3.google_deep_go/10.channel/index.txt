
===================================channel基础==========================================
1.channel.go:

//测试1:(失败)
//结果:死锁
//原因:只有人在写channel,没人在收数据

//测试2:(失败)
//结果:只打印出1
//原因:子协程还没打印出内容,主协程就结束,线程也结束了

//测试3:(成功)
//结果:打印出1和2

//测试4:(成功)
//channel做参数进行传递
//协程抽取出一个普通函数
//结果:打印出1和2

//测试5:(成功)
//channel做为数组

//测试6:(成功)
//channel作为返回值:
//chan<-int意思是:只能往channel里写

//测试7:
//bufferedChannel:
//用处1:用来解决test1中的问题
//用处2:可以提高性能
//增加channel缓冲,缓冲满前即使没人来读,也可以往里写而不阻塞

//测试8:(成功)
//channelClose()
//test8()使用worker7,没有识别发送方是否channelClose ,worker会接受大量空值在正常数据后边
//test8()使用worker8_1()或者worker8_2() ,能够识别发送方已经close的情况
//方式1:
//if判断发送方是否关闭channel,接收方关闭channel时候break
//方式2:
//range自动判断发送方是否关闭channel,接收方关闭channel时候自动退出for

//测试9:(正常)
//不使用channelClose
//发送方不channelClose,接受方使用range来接受channel数据
//最后是worker8_2,range都读不出数据阻塞,主协程运行完退出,线程退出,所有协程也退出
============================channel 等待goroutine结束=======================
2.done.go:

//测试1:(失败)
//解决:
//在1.channel.go:test5()中,主协程用sleep来等子协程执行完毕
//通过增加一个done channel,让子协程去通知父协程自己工作已经完成
//新的问题:
//程序成为串行而不是并行了,看worker序号

//测试2:(失败)
//想要优化test1()实现并行,但是死锁


//测试3:(成功)
//解决test2()死锁的第一种方法:
//让子协程里再开1个协程,单独去往done去写
//结果:worker是乱序的说明是并发(仔细往后看)

//测试4:(成功)
//解决test2()死锁的第二种方法:

========================WaitGroup等待goroutine结束============================
3.sync.go:
//测试1:(成功)
//解决2.done.go中test2()死锁的第三种方法:
//用Golang版本的WaitGroup, 让主协程来等待任务结束
//Add是添加任务, Done是完成了任务, Wait是等待任务
============================channel来遍历树====================================
4.tree:
//打印最大的节点的数值
//子协程去中序树并将树node值发送到channel
//主协程从channel读取获取最大的node值
=============================select============================================
5.select.go:
select的基本使用
select+default实现非阻塞

6.select_job.go:
生成者生产任务太快和消费者消费速慢的问题解决:

7.select_timer.go:
定时器的使用
=============================传统并发机制================================
WaitGroup/Mutex/Cond
8.atmoic


